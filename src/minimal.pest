WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)*) }

program = {
    SOI ~
    (statement ~ ";")* ~
    EOI
}
statement = { assignment | function | call_expr }

identifier        = @{ !(reserved) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
jet               = @{ "jet_" ~ (ASCII_ALPHANUMERIC | "_")+ }
builtin           = @{ "builtin_" ~ (ASCII_ALPHANUMERIC | "_")+ }
witness_name      = @{ (ASCII_ALPHANUMERIC | "_")+ }
reserved          = _{ jet | builtin | "unwrap_left" | "unwrap_right" | "unwrap" | "fold" }

variable_pattern  =  { identifier }
ignore_pattern    = @{ "_" }
product_pattern   =  { "(" ~ pattern ~ "," ~ pattern ~ ")" }
array_pattern     =  { "[" ~ pattern ~ ("," ~ pattern)* ~ ","? ~ "]" }
pattern           =  { ignore_pattern | product_pattern | array_pattern | variable_pattern }
assignment        =  { "let" ~ pattern ~ (":" ~ ty)? ~ "=" ~ expression }

function_name     =  { identifier }
function_params   =  { (identifier ~ ("," ~ identifier)*)? }
function          =  { "fn" ~ function_name ~ "(" ~ function_params ~ ")" ~ block_expression }

left_pattern      =  { "Left(" ~ identifier ~ ")" }
right_pattern     =  { "Right(" ~ identifier ~ ")" }
none_pattern      = @{ "None" }
some_pattern      =  { "Some(" ~ identifier ~ ")" }
false_pattern     = @{ "false" }
true_pattern      = @{ "true" }
match_pattern     =  { left_pattern | right_pattern | none_pattern | some_pattern | false_pattern | true_pattern }

unit_type         = @{ "()" }
sum_type          =  { "Either<" ~ ty ~ "," ~ ty ~ ">" }
product_type      =  { "(" ~ ty ~ "," ~ ty ~ ")" }
option_type       =  { "Option<" ~ ty ~ ">" }
boolean_type      = @{ "bool" }
unsigned_type     = @{ "u128" | "u256" | "u16" | "u32" | "u64" | "u1" | "u2" | "u4" | "u8" }
array_size        = @{ ASCII_DIGIT+ }
array_type        =  { "[" ~ ty ~ ";" ~ array_size ~ "]" }
list_bound        = @{ ASCII_DIGIT+ }
list_type         =  { "List<" ~ ty ~ "," ~ list_bound ~ ">" }
ty                =  { unit_type | sum_type | product_type | option_type | boolean_type | unsigned_type | array_type | list_type }

expression        =  { block_expression | single_expression }
block_expression  =  { "{" ~ (statement ~ ";")* ~ expression ~ "}" }
unit_expr         = @{ "()" }
left_expr         =  { "Left(" ~ expression ~ ")" }
right_expr        =  { "Right(" ~ expression ~ ")" }
product_expr      =  { "(" ~ expression ~ "," ~ expression ~ ")" }
none_expr         = @{ "None" }
some_expr         =  { "Some(" ~ expression ~ ")" }
false_expr        = @{ "false" }
true_expr         = @{ "true" }
call_name         = ${ jet | "unwrap_left" | "unwrap_right" | "unwrap" | function_name }
call_args         =  { (expression ~ ("," ~ expression)*)? }
call_expr         =  { call_name ~ "(" ~ call_args ~ ")" }
unsigned_integer  = @{ ASCII_DIGIT+ }
bit_string        = @{ "0b" ~ ASCII_BIN_DIGIT+ }
byte_string       = @{ "0x" ~ ASCII_HEX_DIGIT+ }
witness_expr      =  { "witness(\"" ~ witness_name ~ "\")" }
variable_expr     =  { identifier }
match_arm         =  { match_pattern ~ "=>" ~ (single_expression ~ "," | block_expression ~ ","?) }
match_expr        =  { "match" ~ expression ~ "{" ~ match_arm ~ match_arm ~ "}" }
array_expr        =  { "[" ~ expression ~ ("," ~ expression)* ~ ","? ~ "]" }
list_expr         =  { "list![" ~ (expression ~ ("," ~ expression)* ~ ","?)? ~ "]" }
list_fold_expr    =  { "fold::<" ~ list_bound ~ ">(" ~ expression ~ "," ~ expression ~ "," ~ (expression ~ ",")? ~ function_name ~ ")" }
for_bound         = @{ ASCII_DIGIT+ }
for_while_expr    =  { "forWhile::<" ~ for_bound ~ ">(" ~ expression ~ "," ~ (expression ~ ",")? ~ function_name ~ ")" }
single_expression =  { unit_expr | left_expr | right_expr | product_expr | none_expr | some_expr | false_expr | true_expr | call_expr | match_expr | array_expr | list_expr | list_fold_expr | for_while_expr | bit_string | byte_string | unsigned_integer | witness_expr | variable_expr | "(" ~ expression ~ ")" }
